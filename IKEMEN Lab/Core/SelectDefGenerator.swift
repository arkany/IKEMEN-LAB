import Foundation

// MARK: - SelectDefGenerator

/// Generates select.def content from a Collection
class SelectDefGenerator {
    
    /// Generate select.def content for a collection
    /// - Parameters:
    ///   - collection: The collection to generate from
    ///   - ikemenPath: Path to IKEMEN GO installation
    /// - Returns: String content for select.def
    static func generate(from collection: Collection, ikemenPath: URL) -> String {
        var lines: [String] = []
        
        // Header comment
        lines.append("; Generated by IKEMEN Lab")
        lines.append("; Collection: \(collection.name)")
        lines.append("; Generated: \(ISO8601DateFormatter().string(from: Date()))")
        lines.append("; DO NOT EDIT - This file is managed by IKEMEN Lab")
        lines.append("")
        
        // [Characters] section
        lines.append("[Characters]")
        
        for entry in collection.characters {
            switch entry.entryType {
            case .character:
                if let folder = entry.characterFolder {
                    if let def = entry.defFile {
                        lines.append("\(folder)/\(def)")
                    } else {
                        // Find the .def file in the folder
                        let defFile = findDefFile(in: folder, ikemenPath: ikemenPath)
                        lines.append("\(folder)/\(defFile)")
                    }
                }
                
            case .randomSelect:
                lines.append("randomselect")
                
            case .emptySlot:
                lines.append("")  // Empty line for grid spacing
            }
        }
        
        lines.append("")
        
        // [ExtraStages] section
        lines.append("[ExtraStages]")
        
        for stageFolder in collection.stages {
            if stageFolder.lowercased().hasSuffix(".def") {
                // It's a direct file reference (e.g. "my_stage.def")
                lines.append("stages/\(stageFolder)")
            } else {
                // It's a folder, find the def file inside
                let defFile = findStageDefFile(in: stageFolder, ikemenPath: ikemenPath)
                lines.append("stages/\(stageFolder)/\(defFile)")
            }
        }
        
        lines.append("")
        
        // [Options] section (standard defaults)
        lines.append("[Options]")
        lines.append("arcade.maxmatches = 6,1,1,0,0,0,0,0,0,0")
        lines.append("team.maxmatches = 4,1,1,0,0,0,0,0,0,0")
        
        return lines.joined(separator: "\n")
    }
    
    /// Write select.def to disk with backup
    /// - Parameters:
    ///   - collection: Collection to generate from
    ///   - ikemenPath: Path to IKEMEN GO installation
    /// - Returns: Result with path to generated file or error
    static func writeSelectDef(for collection: Collection, ikemenPath: URL) -> Result<URL, Error> {
        let selectDefPath = ikemenPath.appendingPathComponent("data/select.def")
        
        // Create backup if file exists
        if FileManager.default.fileExists(atPath: selectDefPath.path) {
            let backupPath = createBackup(of: selectDefPath)
            print("Backed up select.def to: \(backupPath?.path ?? "failed")")
        }
        
        // Generate content
        let content = generate(from: collection, ikemenPath: ikemenPath)
        
        // Write file
        do {
            try content.write(to: selectDefPath, atomically: true, encoding: .utf8)
            return .success(selectDefPath)
        } catch {
            return .failure(error)
        }
    }
    
    /// Validate that all characters in collection exist
    /// - Parameters:
    ///   - collection: Collection to validate
    ///   - ikemenPath: Path to IKEMEN GO installation
    /// - Returns: Array of missing character folder names
    static func validateCollection(_ collection: Collection, ikemenPath: URL) -> [String] {
        var missing: [String] = []
        let fileManager = FileManager.default
        
        for entry in collection.characters {
            guard entry.entryType == .character,
                  let folder = entry.characterFolder else {
                continue
            }
            
            let charPath = ikemenPath.appendingPathComponent("chars/\(folder)")
            if !fileManager.fileExists(atPath: charPath.path) {
                missing.append(folder)
            }
        }
        
        return missing
    }
    
    // MARK: - Private Helpers
    
    private static func findDefFile(in characterFolder: String, ikemenPath: URL) -> String {
        let charPath = ikemenPath.appendingPathComponent("chars/\(characterFolder)")
        
        // Look for .def files
        if let contents = try? FileManager.default.contentsOfDirectory(at: charPath, includingPropertiesForKeys: nil) {
            let defFiles = contents.filter { $0.pathExtension.lowercased() == "def" }
            
            // Prefer file matching folder name
            if let match = defFiles.first(where: { 
                $0.deletingPathExtension().lastPathComponent.lowercased() == characterFolder.lowercased() 
            }) {
                return match.lastPathComponent
            }
            
            // Otherwise use first .def
            if let first = defFiles.first {
                return first.lastPathComponent
            }
        }
        
        // Fallback to folder name
        return "\(characterFolder).def"
    }
    
    private static func findStageDefFile(in stageFolder: String, ikemenPath: URL) -> String {
        let stagePath = ikemenPath.appendingPathComponent("stages/\(stageFolder)")
        
        if let contents = try? FileManager.default.contentsOfDirectory(at: stagePath, includingPropertiesForKeys: nil) {
            let defFiles = contents.filter { $0.pathExtension.lowercased() == "def" }
            
            if let match = defFiles.first(where: { 
                $0.deletingPathExtension().lastPathComponent.lowercased() == stageFolder.lowercased() 
            }) {
                return match.lastPathComponent
            }
            
            if let first = defFiles.first {
                return first.lastPathComponent
            }
        }
        
        return "\(stageFolder).def"
    }
    
    private static func createBackup(of url: URL) -> URL? {
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyyMMdd-HHmmss"
        let timestamp = formatter.string(from: Date())
        
        let backupName = "select.def.backup.\(timestamp)"
        let backupURL = url.deletingLastPathComponent().appendingPathComponent(backupName)
        
        do {
            try FileManager.default.copyItem(at: url, to: backupURL)
            return backupURL
        } catch {
            print("Failed to create backup: \(error)")
            return nil
        }
    }
}
